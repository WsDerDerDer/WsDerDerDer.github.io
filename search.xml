<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ugui实现简单摇杆</title>
      <link href="/2020/05/31/ugui-shi-xian-jian-dan-yao-gan/"/>
      <url>/2020/05/31/ugui-shi-xian-jian-dan-yao-gan/</url>
      
        <content type="html"><![CDATA[<h2 id="Unity-Ugui实现简单摇杆"><a href="#Unity-Ugui实现简单摇杆" class="headerlink" title="Unity Ugui实现简单摇杆"></a>Unity Ugui实现简单摇杆</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>利用Unity的ScrollRect组件</li></ul><ol><li>在Canvas上创建如此结构的空物体,在Restrict上添加Image组件作为背景图片,</li></ol><p>在Handel上添加Image组件,为摇杆的图标.</p><p><img src="http://i2.tiimg.com/720150/ad1476373d27778e.png" alt=""></p><ol start="2"><li>创建C#脚本Joystic,并拖到Joystic上,编辑脚本,代码如下</li></ol><pre><code>using System.Collections;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;//继承ScrollRect组件,重写其OnDrag实现摇杆功能public class Joystic : ScrollRect{    private float radius;                    //区域半径    private Vector2 Outvalue;    protected override void Start()          //以Vector2为输出值    {         //sizeDelta:文档意思为 矩阵变换的大小相对于锚点之间的距离         //就是RectTransform上的Width和Height 两者的大小在此要设为相同值        radius = (transform as RectTransform).sizeDelta.x * 0.5f;           StartCoroutine(Handel());    }    public override void OnDrag(PointerEventData eventData)    {        base.OnDrag(eventData);        //content的锚点位置        Vector2 pos = content.anchoredPosition;        //当摇杆位置超出半径需要限制        if (pos.magnitude &gt; radius)        {            //归一化pos并乘以半径为最大值            Vector2 posEnd = pos.normalized * radius;            //设置锚点位置            SetContentAnchoredPosition(posEnd);        }    }    //我用的一个协程,也可以在update中执行    IEnumerator Handel()    {        while (true)        {            Outvalue.x = (content.anchoredPosition / radius).x;            Outvalue.y = (content.anchoredPosition / radius).y;            yield return new WaitForSeconds(0.02f);        }    }}</code></pre><ol start="3"><li>Tip:MoveMent Type要设为Elastic即弹性的</li></ol><ul><li>根据输出值来控制人物.</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2020/05/30/mou-pao-pai-xu/"/>
      <url>/2020/05/30/mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h4 id="排序过程"><a href="#排序过程" class="headerlink" title="排序过程"></a>排序过程</h4><ol><li>将第一个和第二个的记录的关键字进行比较,若为逆序r[1].key&gt;r[2].key,</li></ol><p>则交换;然后如此比较至n-1个和n个记录为止—第一趟冒泡排序,结果关键字</p><p>最大的记录被安置在最后一个记录上.</p><ol start="2"><li>对前n-1个记录进行第二趟冒泡排序,结果使关键字次大的记录在n-1的位</li></ol><p>置.</p><ol start="3"><li>重复过程,直到在一趟排序过程中没有交换过程.</li></ol><h4 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C#)"></a>代码(C#)</h4><pre><code>using System;class Program{    static void Main(string[] args)    {        Random rd = new Random();        SortT[] sortArray = new SortT[10];        //随机生成需要排序的对象        for (int i = 0; i &lt; sortArray.Length; i++)        {            SortT sort = new SortT() { key = rd.Next(0, 100) };            sortArray[i] = sort;            Console.WriteLine("随机值" + i + ":" + sort.key);        }        Bubble_sort(sortArray, sortArray.Length);        Console.WriteLine("\n");        for (int i = 0; i &lt; sortArray.Length; i++)        {            Console.WriteLine("排序值" + i + ":" + sortArray[i].key);        }        Console.ReadKey();    }    /// &lt;summary&gt;    /// 冒泡排序    /// &lt;/summary&gt;    static void Bubble_sort(SortT[] sort, int n)    {        int m = n, j, flag = 1; //flag :记录是否发生交换        SortT Temp;        while ((m &gt; 1) &amp;&amp; flag == 1)        {            flag = 0;            for (j = 0; j &lt; m - 1; j++)  //一次交换过程为将最大值放在最后            {                if (sort[j].key &gt; sort[j + 1].key)                {                    Temp = sort[j];                    sort[j] = sort[j + 1];                    sort[j + 1] = Temp;                    flag = 1;   //发生交换                }            }            m--;        }    }    public class SortT    {        public int key;    }}</code></pre><p><img src="http://i2.tiimg.com/720150/440c21d5d69ba56f.png" alt="结果"></p><ol start="4"><li>时间复杂度</li></ol><p>最好情况(正序):比较次数:n-1 移动次数:0 </p><p>最坏情况(逆序):比较次数1/2(n^2-n) 移动次数:3/2(n^2-n)</p><ol start="5"><li>空间复杂度</li></ol><p>S(n)=o(1)</p><ol start="6"><li>可从上次交换的位置继续进行排序提高效率</li></ol><pre><code>void Bubble_sort(SortT[] sort, int n){        int m = n, j;  //LastChange:下次排序位置        SortT Temp;        while (m &gt; 1)        {            int LastChange = 1;            for (j = 0; j &lt; m-1 ; j++)  //一次交换过程为将最大值放在最后            {                if (sort[j].key &gt; sort[j + 1].key)                {                    Temp = sort[j];                    sort[j] = sort[j + 1];                    sort[j + 1] = Temp;                    LastChange = j; //更新排序位置                }            }            m = LastChange;        }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
